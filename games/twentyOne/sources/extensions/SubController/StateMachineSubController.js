export default class StateMachineSubController extends logic.fms.StateMachineSubController {	/**	 * Main controller	 * @type {*}	 */	mainController;		constructor(mainController) {		super(mainController);	}		/**	 * @public	 * Create states for main controller	 */	createStateMachine() {		const mainController = this.mainController;		game.states          = {};		game.states.machine  = this.stateMachine.createMachine({			initialState: 'initial',			initial: {				actions: {					onEnter() {},					onExit() {},				},				transitions: {					switch: {						target: 'introGame',						action() {},					},				},			},			initialGame: {				actions: {					onEnter() {						const state = {state: 'initialGame'};						mainController.components.ui.clearBet();						mainController.updateStateUI(state);					},					onExit() {},				},				transitions: {					switch: {						target: 'betGame',						action() {},					},				},			},			betGame: {				actions: {					onEnter() {						const state = {state: 'betGame'};						mainController.updateStateUI(state);					},					onExit() {},				},				transitions: {					switch: {						target: 'startGame',						action() {},					},				},			},			startGame: {				actions: {					onEnter() {						const state = {state: 'startGame'};						mainController.updateStateUI(state);						const resultRound    = () => mainController.resultRound();						const giveDealerCard = () => mainController.giveDealerCard(true, resultRound);						mainController.giveUserCard(true, giveDealerCard);					},					onExit() {},				},				transitions: {					switch: {						target: 'selectGame',						action() {},					},				},			},			recovery: {				actions: {					onEnter() {						const state = {state: 'recovery'};												mainController.model.temporaryBet = mainController.model.game.params.sumBet;												game.env.gameId = mainController.model.game.params.gameId;												mainController.updateUI();						mainController.updateStateUI(state);												core.call(() => {							mainController.updateStateUI(state);							mainController.updateUI();														const resultRound    = () => mainController.resultRound();							const giveDealerCard = () => mainController.giveDealerCard(true, resultRound);														mainController.giveUserCard(true, giveDealerCard);						}, 3000);					},					onExit() {},				},				transitions: {					switch: {						target: 'selectGame',						action() {},					},				},			},			selectGame: {				actions: {					onEnter() {						game.model.recovery = false;												const state = {state: 'selectGame'};						mainController.updateStateUI(state);					},					onExit() {},				},				transitions: {					switch: {						target: 'gameOver',						action() {},					},				},			},			hit: {				actions: {					onEnter() {						const state = {state: 'hit'};						mainController.updateStateUI(state);						const resultRound = () => mainController.resultRound();						mainController.giveUserCard(false, resultRound);					},					onExit() {},				},				transitions: {					switch: {						target: 'gameOver',						action() {},					},				},			},			stand: {				actions: {					onEnter() {						const state = {state: 'stand'};						mainController.updateStateUI(state);						const resultRound = () => mainController.resultRound();						mainController.stayDealerCard(resultRound);					},					onExit() {},				},				transitions: {					switch: {						target: 'gameOver',						action() {},					},				},			},			gameOver: {				actions: {					onEnter() {												mainController.updateUI();												const state = {state: 'gameOver'};												mainController.updateStateUI(state);						mainController.showEndGamePopup();					},					onExit() {										},				},				transitions: {					switch: {						target: 'initialGame',						action() {},					},				},			},		});		game.states.state    = game.states.machine.value;				this.mainController.state  = game.states.state;		this.mainController.states = game.states;	}}